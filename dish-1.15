#!/bin/sh

###settings from ersh-3.1
###Written by Maarten Litmaath in 1991.
ersh () {
hostname=
lflag=
nflag=
user=

case $1 in
-l)
	;;
*)
	hostname=${1?'hostname expected'}
	shift
esac

case $1 in
-l)
	lflag=-l
	shift
	user=${1?'username expected after -l flag'}
	shift
esac

case $1 in
-n)
	nflag=-n
	shift
esac

case $hostname in
'')
	hostname=${1?'hostname expected'}
	shift
esac

id=ersh.$$.`date | awk '{ print $4; }'`
hangup=99

AWK='
	prprev == 1 {
		print prev0;
		prprev = 0;
	}
	$1 == "'$id'" {
		prev0 = $0;
		prev2 = $2;
		prev3 = $3;
		prprev = 1;
		next;
	}
	{
		print;
	}
	END {
		if (prprev == 0) {
			exit('$hangup');
		}
		if (prev2 ~ /^[0-9]+0$/) {
			exit(prev2 / 10);
		}
		if (prev2 ~ /^0$/ && prev3 ~ /^[0-9]+$/) {
			exit(prev3);
		}
		print prev0;
		exit('$hangup');
	}
'

exec 3>&1

# patch to localhost through
# UTC ADy001999m03d31 added by Seisei Yamaguchi 
# 27JUL99 matto
# remove "hostname -s" because some OS does not have -s option for hostname
case $hostname in
localhost|$(echo -n `hostname`))
	cmd=${*-:}	# for $cmd used by other part. 
	eval $cmd	# eval for avoid syntax-error.  
;;
*)
#added by matto 27JUL99
#It causes error when the user command outputs some string w/o last linefeed
#character to stderr.
#	cmd="( ${*-:} ); exec sh -c 'echo $id "'"$0 $1" | sed q >&2'\'' $?0 "$status"'
	cmd="( ${*-:}; sh -c 'echo >&2' ); exec sh -c 'echo $id "'"$0 $1" | sed q >&2'\'' $?0 "$status"'
	$RSH "$hostname" $lflag $user $nflag "$cmd" 2>&1 >&3 3>&- |
		awk "$AWK" >&2 3>&-
esac
}	
#end of ersh


die () {
	echo "$*" 1>&2
	exit 1
}

usage () {
	die '$Id: dish,v 1.15 1999/08/06 08:28:18 matto Exp $'"
usage:  $script [options] foo [x] [bar [y] ... ] -c cmds
Dish executes the specified command on one of the remote hosts.
It distributes at most x jobs to the remote host foo and y jobs to bar.
Default number of jobs is 1 if it is omitted.

Options
    -h, --help         Show this message.
    -i, --interactive  By default, dish ignores any input from stdin.
                       With this option, dish reads from stdin.
    -v, --verbose      Display debug messages
    -r, --refresh      Remove lock files and go.
    -p, --pwd PATH     Specify current directory explicitly.
                       dish usually gets current path from PWD environment 
                       variable. However, some shells do not set PWD variable
                       and dish tries to get it by pwd command, which only
                       returns the absolute	path. Representation of current 
                       absolute path sometimes differs between local and 
                       remote host when the current path involves symbolic 
                       link. 
    -c     Terminator symbol of host list.
    cmds   Bourne shell commands to be executed."
}

on_usage () {
	die '$Id: dish,v 1.15 1999/08/06 08:28:18 matto Exp $'"
usage:  $script [options] hostname cmds
  or    $script [options] hostname cmds
Options
    -h, --help         Show this message.
    -n                 Ignores any input from stdin.
    -v, --verbose      Display debug messages
    -p, --pwd PATH     Specify current directory explicitly.
                       dish usually gets current path from PWD environment 
                       variable. However, some shells do not set PWD variable
                       and dish tries to get it by pwd command, which only
                       returns the absolute path. Representation of current 
                       absolute path sometimes differs between local and 
                       remote host when the current path involves symbolic 
                       link. 
    cmds   Bourne shell commands to be executed."
}

dish () {
#make work directory.
dir="$HOME/.dish"
unset verbose
interactive="-n"
unset refresh
while [ $# -gt 0 ]
do
	case $1 in
		-i|--interactive)
			interactive=""
			shift
			;;
		-v|--verbose)
			verbose=true
			shift
			;;
		-h|--help)
			usage
			;;
		-p|--pwd)
			shift
			cwd=$1
			shift
			;;
		-r|--refresh)
			refresh=true
			shift
			;;
		*)
			break
			;;
	esac
done

#split arguments
# UTC ADy001999m04d20	Patched by Seisei Yamaguchi
#hosts=`echo $* | sed -e 's/[ 	]-c[ 	].*$//' -e 's/:/ /g'`	#Seisei
#hosts=`echo $* | sed -e 's/-c.*$//' | sed -e 's/:/ /g'`	#orig

case $# in		#Seisei
	0) usage ;;	#
esac			#

unset hosts
while [ $1 != "-c" ]
do
	hosts="$hosts $1"
	shift
	case $# in
	    0) usage ;;
	esac
	njob=1
	if ( echo $1 | grep -q '^[0-9]*$' )
	then
	    njob=$1
	    shift
	    case $# in
		0) usage ;;
	    esac
	fi
	hosts="$hosts $njob"
done
shift
args=$*
case $verbose in
true)
    echo "Pwd: $cwd" >&2
    echo "Host list: $hosts" >&2
    echo "Argument list: $args" >&2
    ;;
esac

# clean locks
if [ -d $dir ]
then
    case $refresh in
	true)
	    [ -n "$verbose" ] && echo "Remove lock files in ${dir}..." >&2
	    rm $dir/*
	    ;;
    esac
else
    mkdir $dir || die "Cannot make $dir"
fi

case X${hosts}X in
XX) usage ;;
esac
case X${args}X in
XX) usage ;;
esac

while :
do
	set $hosts
  	while [ $# -gt 1 ]
  	do
		[ -n "$verbose" ] && echo "Trying host: $1" >&2
    	i=$2
    	while [ $i -gt 0 ]
  		do
			[ -n "$verbose" ] && echo "Trying job: $i" >&2
      		lock=$dir/$1:$i

		# patch to safety locking
		# UTC ADy001999m04d22 fixed by Seisei Yamaguchi 
		#if [ ! -e $lock ]	#orig
		if	[ ! -e $lock ] && ln -s $$ $lock 2>/dev/null	#Seisei
      		then
				#touch a lock file
				[ -n "$verbose" ] && echo "Lock file: $lock" >&2
    			#>$lock		#UTC ADy001999m04d22 Seisei Yamaguchi 
				# echo "$ersh $1 $interactive \"sh -c \'cd $cwd; $args \'\""
				[ -n "$verbose" ] && echo "Invoking remote command: ersh $1 -n \"sh -c 'cd $cwd && ( $args )'\"" >&2
        		ersh $1 $interactive "sh -c 'cd $cwd && ( $args ) '"
        		ret=$?
        		#remove a lock file
				rm $lock #|| die "Lock file is removed."
				[ -n "$verbose" ] && echo "Unlock file: $lock" >&2
        		exit $ret
      		fi
      		i=`expr $i - 1`
   		done
    	shift 2
  	done
  	sleep 1
done
} #end of dish()

on () {
	unset verbose
	interactive=""
	while [ $# -gt 0 ]
	do
		case $1 in
			-n)
				interactive="-n"
				shift
				;;
			-d|-v|--verbose)
				verbose=true
				shift
				;;
			-h|--help)
				on_usage
				;;
	    	-p|--pwd)
				shift
				cwd=$1
				shift
				;;
			*)
				break
				;;
		esac
	done
	if [ ! -n "$target" ]
	then
		 target=$1
		 shift
 	fi
	[ $# -le 0 ] && on_usage
	[ -n "$verbose" ] && echo "Target: $target" >&2
	[ -n "$verbose" ] && echo "Pwd: $cwd" >&2
	[ -n "$verbose" ] && echo "Invoking remote command: ersh $target $interactive \"sh -c 'cd $cwd; $* '\"" >&2
	ersh $target $interactive "sh -c 'cd $cwd; $* '"
}



#trap 'echo "Interrupted" 1>&2 ; if [ -e ${lock?"Not locked."} ]; then rm $lock; fi'  1 2 15
#trap those signals
trap 'echo "Interrupted" 1>&2'  1 2 15

#option handling
#use if envvar PWD is set, do pwd otherwise.
#result of pwd command is sometimes inappropriate when the path is symlinked.
cwd=${PWD-`pwd`}
RSH=`which remsh` || RSH=`which rsh` || die "Cannot find remote shell."
script=`basename $0`
case $script in
	on)
		target=""
		on $*
		;;
	dish)
		dish $*
		;;
	*)
		target=$script
		on $*
		;;
esac

